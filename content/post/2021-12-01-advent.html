---
title: Advent of Code 2021
date: '2021-12-01T09:00:00+00:00'
slug: advent-2021
categories: ['R']
images: ['/img/2020/adventofcode.jpg']
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<p>It’s that time of year again.
And not just for <a href="/2016/12/07/santa/">Secret Santa</a>—it’s time for the <a href="https://adventofcode.com/">Advent of Code</a>, a series of programming
puzzles in the lead-up to Christmas.</p>
<p>I’m doing the 2021 challenge in R—in the form of an open-source <a href="https://github.com/Selbosh/adventofcode2021">R package</a>, to demonstrate a <a href="https://personalpages.manchester.ac.uk/staff/david.selby/rthritis/2021-11-19-unittesting/">test-driven</a> workflow.</p>
<div style="text-align:center;">
<div class="github-card" data-github="Selbosh/adventofcode2021" data-width="400" data-height="" data-theme="default" style="display:block; margin:0 auto;">

</div>
</div>
<script src="//cdn.jsdelivr.net/github-cards/latest/widget.js"></script>
<p>Each puzzle description typically comes with a few simple examples of inputs and outputs.
We can use these to define expectations for unit tests with the <a href="https://testthat.r-lib.org/"><strong>testthat</strong></a> package.
Once a function passes the unit tests, it should be ready to try with the main puzzle input.</p>
<p>Check my <a href="https://github.com/Selbosh/adventofcode2021"><strong>adventofcode2021</strong></a> repository on GitHub for the latest.</p>
<pre class="r"><code>remotes::install_github(&#39;Selbosh/adventofcode2021&#39;)</code></pre>
<ol style="list-style-type: decimal">
<li><a href="#day1">Sonar Sweep</a></li>
<li><a href="#day2">Dive!</a></li>
<li><a href="#day3">Binary Diagnostic</a></li>
<li><a href="#day4">Giant Squid</a></li>
<li><a href="#day5">Hydrothermal Venture</a></li>
<li><a href="#day6">Lanternfish</a></li>
<li><a href="#day7">The Treachery of Whales</a></li>
<li><a href="#day8">Seven Segment Search</a></li>
<li><a href="#day9">Smoke Basin</a></li>
<li><a href="#day10">Syntax Scoring</a></li>
<li><a href="#day11">Dumbo Octopus</a></li>
</ol>
<div id="day1" class="section level2">
<h2>Day 1 - <a href="https://adventofcode.com/2021/day/1">Sonar Sweep</a></h2>
<div id="increases" class="section level3">
<h3>Increases</h3>
<p>To count the number of times elements are increasing in a vector it’s as simple as</p>
<pre class="r"><code>depths &lt;- c(199, 200, 208, 210, 200, 207, 240, 269, 260, 263)
sum(diff(depths) &gt; 0)</code></pre>
<pre><code>## [1] 7</code></pre>
<p>for which I defined a function called <a href="https://github.com/Selbosh/adventofcode2021/blob/main/R/day01.R#L91-L93"><code>increases</code></a>.</p>
</div>
<div id="rolling-sum" class="section level3">
<h3>Rolling sum</h3>
<p>For part two, we first want to calculate the three-depth moving sum, then we count the increases as in part one.
There are plenty of solutions in external R packages for getting lagged (and leading) vectors, for instance <code>dplyr::lag()</code> and <code>dplyr::lead()</code>:</p>
<pre class="r"><code>depths + dplyr::lead(depths) + dplyr::lead(depths, 2)</code></pre>
<pre><code>##  [1] 607 618 618 617 647 716 769 792  NA  NA</code></pre>
<p>Or you could even calculate the rolling sum using a pre-made solution in <strong>zoo</strong> (Z’s Ordered Observations, a time-series analysis package).</p>
<pre class="r"><code>zoo::rollsum(depths, 3)</code></pre>
<pre><code>## [1] 607 618 618 617 647 716 769 792</code></pre>
<p>To avoid loading any external packages at this stage, I defined my own base R function called <a href="https://github.com/Selbosh/adventofcode2021/blob/main/R/day01.R#L99-L101"><code>rolling_sum()</code></a>, which uses <code>tail</code> and <code>head</code> with negative lengths to omit the first and last elements of the vector:</p>
<pre class="r"><code>head(depths, -2) + head(tail(depths, -1), -1) + tail(depths, -2)</code></pre>
<pre><code>## [1] 607 618 618 617 647 716 769 792</code></pre>
<p>As <a href="https://twitter.com/schochastics/status/1466062839077027845">David Schoch points out</a>, you can just use the <code>lag</code> argument of <code>diff</code> to make this entire puzzle into a one-liner:</p>
<pre class="r"><code>sapply(c(1, 3), \(lag) sum(diff(depths, lag) &gt; 0))</code></pre>
<pre><code>## [1] 7 5</code></pre>
</div>
</div>
<div id="day2" class="section level2">
<h2>Day 2 - <a href="https://adventofcode.com/2021/day/2">Dive!</a></h2>
<div id="depth-sum" class="section level3">
<h3>Depth sum</h3>
<p>Read in the input as a two-column data frame using <code>read.table()</code>.
I gave mine nice column names, <code>cmd</code> and <code>value</code>, but this isn’t essential.</p>
<p>Then take advantage of the fact that <code>TRUE == 1</code> and <code>FALSE == 0</code> to make a mathematical <code>ifelse</code>-type statement for the horizontal and vertical movements.
In my R package, this is implemented as a function called <a href="https://github.com/Selbosh/adventofcode2021/blob/main/R/day02.R#L70-L76"><code>dive()</code></a>:</p>
<pre class="r"><code>x &lt;- (cmd == &#39;forward&#39;) * value
y &lt;- ((cmd == &#39;down&#39;) - (cmd == &#39;up&#39;)) * value
sum(x) * sum(y)</code></pre>
</div>
<div id="cumulative-depth-sum" class="section level3">
<h3>Cumulative depth sum</h3>
<p>Part two is much like part one, but now <code>y</code> represents (change in) aim, and (change in) depth is derived from that.
Don’t forget the function <code>cumsum()</code>, which can save you writing a loop!
Here is the body of my function <a href="https://github.com/Selbosh/adventofcode2021/blob/main/R/day02.R#L80-L87"><code>dive2()</code></a>:</p>
<pre class="r"><code>x &lt;- (cmd == &#39;forward&#39;) * value
y &lt;- ((cmd == &#39;down&#39;) - (cmd == &#39;up&#39;)) * value
depth &lt;- cumsum(y) * x
sum(x) * sum(depth)</code></pre>
</div>
</div>
<div id="day3" class="section level2">
<h2>Day 3 - <a href="https://adventofcode.com/2021/day/2">Binary Diagnostic</a></h2>
<div id="power-consumption" class="section level3">
<h3>Power consumption</h3>
<p>There are a few different ways you could approach part one, but my approach was first to read in the data as a data frame of binary integers using the function <code>read.fwf()</code>.
Then, find the most common value in each column using the base function <code>colMeans()</code> and rounding the result.</p>
<p>According to the instructions, in the event of a tie you should take 1 to be the most common digit.
Although this is familiar to real life—0.5 rounds up to 1—computers <a href="https://en.wikipedia.org/wiki/Rounding#Round_half_to_even">don’t work this way</a>: R rounds to even instead (see <code>?round</code>).
Because zero is even, that means <code>round(0.5)</code> yields 0.
To get around this, add 1 before rounding, then subtract it again.</p>
<p>My function <a href="https://github.com/Selbosh/adventofcode2021/blob/main/R/day03.R#L78-L81"><code>power_consumption()</code></a>, which once again takes advantage of <code>TRUE</code> being equivalent to 1 and <code>FALSE</code> to 0:</p>
<pre class="r"><code>common &lt;- round(colMeans(x) + 1) - 1
binary_to_int(common) * binary_to_int(!common)</code></pre>
<p>To convert a vector of binary digits to decimal, I use the following <a href="https://github.com/Selbosh/adventofcode2021/blob/main/R/day03.R#L104-L106">utility function</a>:</p>
<pre class="r"><code>binary_to_int &lt;- function(x) {
  sum(x * 2 ^ rev(seq_along(x) - 1))
}</code></pre>
<p>However, if using a string representation then there’s a handy function in base R called <code>strtoi()</code> that you could also use for this (<a href="https://twitter.com/_Riinu_/status/1466681283887648769">thanks to Riinu Pius for that tip</a>).</p>
</div>
<div id="life-support" class="section level3">
<h3>Life support</h3>
<p>Part two finds the common digits in a successively decreasing set of binary numbers.
A loop is appropriate here, since we can halt once there is only one number left.
As this loop will only run (at most) 12 times in total, it shouldn’t be too slow in R.</p>
<p>Function <a href="https://github.com/Selbosh/adventofcode2021/blob/main/R/day03.R#L85-L98"><code>life_support()</code></a>:</p>
<pre class="r"><code>life_support &lt;- function(x) {
  oxygen &lt;- co2 &lt;- x
  for (j in 1:ncol(x)) {
    if (nrow(oxygen) &gt; 1) {
      common &lt;- most_common(oxygen)
      oxygen &lt;- oxygen[oxygen[, j] == common[j], ]
    }
    if (nrow(co2) &gt; 1) {
      common &lt;- most_common(co2)
      co2 &lt;- co2[co2[, j] != common[j], ]
    }
  }
  binary_to_int(oxygen) * binary_to_int(co2)
}</code></pre>
<p>There might be cleverer ways of doing this.</p>
</div>
</div>
<div id="day4" class="section level2">
<h2>Day 4 - <a href="https://adventofcode.com/2021/day/4">Giant Squid</a></h2>
<div id="bingo" class="section level3">
<h3>Bingo</h3>
<p>This is one of those problems where half the battle is working out which data structure to use.
I wrote a function <a href="https://github.com/Selbosh/adventofcode2021/blob/main/R/day04.R#L80-L84"><code>read_draws()</code></a> that reads in the first line of the file to get the drawn numbers, then separately reads in the remainder of the file to get the bingo cards stacked as a data frame.
Later we take advantage of the fact that the bingo cards are square to split the data frame into a list of matrices.</p>
<pre class="r"><code>read_draws &lt;- function(file) {
  draws &lt;- scan(file, sep = &#39;,&#39;, nlines = 1, quiet = TRUE)
  cards &lt;- read.table(file, skip = 1)
  list(draws = draws, cards = cards)
}</code></pre>
<p>As numbers are called out, I replace them in the dataset with <code>NA</code>s.
Then the helper <a href="https://github.com/Selbosh/adventofcode2021/blob/main/R/day04.R#L86-L91"><code>score_card()</code></a> counts the number of <code>NA</code>s in each row and column.
If there are not enough, we return zero, else we calculate the score.</p>
<pre class="r"><code>score_card &lt;- function(mat, draw) {
  marked &lt;- is.na(mat)
  if (all(c(rowMeans(marked), colMeans(marked)) != 1))
    return(0)
  sum(mat, na.rm = TRUE) * draw
}</code></pre>
<p>Then we put it all together, looping through the draws, replacing numbers with <code>NA</code> and halting as soon as someone wins.
Function <a href="https://github.com/Selbosh/adventofcode2021/blob/main/R/day04.R#L98-L111"><code>play_bingo()</code></a> is defined as follows, using just base R commands:</p>
<pre class="r"><code>play_bingo &lt;- function(draws, cards) {
  size &lt;- ncol(cards)
  ncards &lt;- nrow(cards) / size
  ids &lt;- rep(1:ncards, each = size)

  for (d in draws) {
    cards[cards == d] &lt;- NA
    score &lt;- sapply(split(cards, ids), score_card, draw = d)
    if (any(score &gt; 0))
      return(score[score &gt; 0])
  }
}</code></pre>
</div>
<div id="last-caller" class="section level3">
<h3>Last caller</h3>
<p>Part two is very similar, but we throw away each winning bingo card as we go to avoid redundant computation, eventually returning the score when there is only one left.
Here is function <a href="https://github.com/Selbosh/adventofcode2021/blob/main/R/day04.R#L115-L131"><code>play_bingo2()</code></a>, which uses the same two utility functions:</p>
<pre class="r"><code>play_bingo2 &lt;- function(draws, cards) {
  size &lt;- ncol(cards)

  for (d in draws) {
    ncards &lt;- nrow(cards) / size
    ids &lt;- rep(1:ncards, each = size)
    cards[cards == d] &lt;- NA
    score &lt;- sapply(split(cards, ids), score_card, draw = d)
    if (any(score &gt; 0)) {
      if (ncards == 1)
        return(score[score &gt; 0])
      cards &lt;- cards[ids %in% which(score == 0), ]
    }
  }
}</code></pre>
<p>Further optimizations are possible.
For example: as written, we calculate every intermediate winner’s score, but we only really need to do it for the first (part 1) and last (part 2) winners.</p>
<p>Also, we could draw more than one number at a time, as we know that nobody’s going to win until at least the fifth draw (for 5×5 cards) and from there, increment according to the minimum number of unmarked numbers on any row or column.</p>
<p>I didn’t bother implementing either of these, as it already runs quickly enough.</p>
</div>
</div>
<div id="day5" class="section level2">
<h2>Day 5 - <a href="https://adventofcode.com/2021/day/5">Hydrothermal Venture</a></h2>
<p>For a while I tried to think about clever mathematical ways to solve the system of inequalities, but this gets complicated when working on a grid, and where some segments are collinear.
In the end it worked out quicker to what seems like a ‘brute force’ approach:
generate all the points on the line segments and then simply count how many times they appear.</p>
<p>This is a problem that really lends itself to use of <strong>tidyr</strong> functions like <a href="https://tidyr.tidyverse.org/reference/separate.html"><code>separate()</code></a> and <a href="https://tidyr.tidyverse.org/reference/nest.html"><code>unnest()</code></a>, so naturally I made life harder for myself by doing it in base R, instead.</p>
<p>First, read in the coordinates as a data frame with four columns, <code>x1</code>, <code>y1</code>, <code>x2</code> and <code>y2</code>.
The <em>nice</em> way to do this is with <code>tidyr::separate()</code> but <code>strsplit()</code> works just fine too.
Here is my parsing function, <a href="https://github.com/Selbosh/adventofcode2021/blob/main/R/day05.R#L77-L82"><code>read_segments()</code></a>:</p>
<pre class="r"><code>read_segments &lt;- function(x) {
  lines &lt;- do.call(rbind, strsplit(readLines(x), &#39;( -&gt; |,)&#39;))
  storage.mode(lines) &lt;- &#39;numeric&#39;
  colnames(lines) &lt;- c(&#39;x1&#39;, &#39;y1&#39;, &#39;x2&#39;, &#39;y2&#39;)
  as.data.frame(lines)
}</code></pre>
<p>This is one of the few puzzles where the solution to part two is essentially contained in part one.
Depending on how you implement your home-rolled <code>unnest</code>-like function, it could just be a case of filtering out the diagonal lines in part one.
I make liberal use of <code>mapply</code> for looping over two vectors at once.</p>
<p>In the penultimate line, we take advantage of vector broadcasting, which handles all the horizontal and vertical lines where you have multiple coordinates on one axis paired with a single coordinate on the other.
For the diagonal lines, there is a 1:1 relationship so the coordinates just bind together in pairs.
Finally, we work out how to count the rows, without using <code>dplyr::count()</code>.
If you convert to a data frame, then <code>table()</code> does this for you.</p>
<pre class="r"><code>count_intersections &lt;- function(lines, part2 = FALSE) {
  if (!part2)
    lines &lt;- subset(lines, x1 == x2 | y1 == y2)
  x &lt;- mapply(seq, lines$x1, lines$x2)
  y &lt;- mapply(seq, lines$y1, lines$y2)
  xy &lt;- do.call(rbind, mapply(cbind, x, y))
  sum(table(as.data.frame(xy)) &gt; 1)
}</code></pre>
<p>I’m fairly pleased to get the main solution down to <a href="https://github.com/Selbosh/adventofcode2021/blob/main/R/day05.R#L89-L96">essentially four lines of code</a>, though I’m certain that there are more computationally efficient ways of tackling this problem—if you value computer time more than your own time.</p>
<p>For the tidyverse approach, see <a href="https://twitter.com/drob/status/1467361848525787138">David Robinson’s solution</a>.</p>
</div>
<div id="day6" class="section level2">
<h2>Day 6 - <a href="https://adventofcode.com/2021/day/6">Lanternfish</a></h2>
<p>In this problem, we have many fish with internal timers.
As the instructions suggest, we will have exponential growth, so it’s not a good idea to keep track of each individual fish as you’ll soon run out of memory.
On the other hand, there are only nine possible states for any given fish to be in: the number of days until they next reproduce.
So we can store a vector that simply tallies the number of fish in each state.</p>
<p>On each day, we can shuffle the fish along the vector, decreasing the number of days for each group of fish by 1, and adding new cohorts of fish at day 6, to represent parent fish resetting their timers, and at day 8 to represent the newly hatched lanternfish.
My short function <a href="https://github.com/Selbosh/adventofcode2021/blob/main/R/day06.R#L72-L77"><code>lanternfish()</code></a>:</p>
<pre class="r"><code>lanternfish &lt;- function(x, days = 80) {
  fish &lt;- as.double(table(factor(x, levels = 0:8)))
  for (i in 1:days)
    fish &lt;- c(fish[2:7], fish[8] + fish[1], fish[9], fish[1])
  sum(fish)
}</code></pre>
<p>Because R indexes from 1 rather than 0, the element <code>fish[1]</code> represents the number of fish with 0 days left, <code>fish[2]</code> represents the number with 1 day left, and so on.
If you find this confusing, you can index from zero instead, thanks to the new <a href="https://github.com/Selbosh/index0"><strong>index0</strong> package</a>:</p>
<pre class="r"><code>lanternfish0 &lt;- function(x, days = 80) {
  fish &lt;- as.double(table(factor(x, levels = 0:8)))
  for (i in 1:days) {
    fish &lt;- index0::index_from_0(fish)
    fish &lt;- c(fish[1:6], fish[7] + fish[0], fish[8], fish[0])
   }
  sum(fish)
}</code></pre>
<p>There is a slightly different way to perform the updates.
<a href="https://twitter.com/drob/status/1467727330663534594">David Robinson suggested</a> an approach based on linear algebra.
Here we apply the same procedure as above, but via matrix multiplication.
It takes about the same time to run.</p>
<pre class="r"><code>lanternfish &lt;- function(x, days = 80) {
  fish &lt;- table(factor(x, levels = 0:8))
  mat &lt;- matrix(0, 9, 9)
  mat[cbind(2:9, 1:8)] &lt;- 1 # decrease timer for fish w/ 1-8 days left
  mat[1, c(7, 9)] &lt;- 1      # add &#39;new&#39; fish with 6 &amp; 8 days left
  for (i in 1:days)
    fish &lt;- fish %*% mat
  sum(fish)
}</code></pre>
<p>Day 6 is another puzzle where the solutions for parts one and two are essentially the same.
The only thing to be careful of on part two is that you don’t run into integer overflow.
If you do, make sure the numbers you’re adding together are of type <code>double</code>.</p>
</div>
<div id="day7" class="section level2">
<h2>Day 7 - <a href="https://adventofcode.com/2021/day/7">The Treachery of Whales</a></h2>
<div id="median" class="section level3">
<h3>Median</h3>
<p>While it’s possible to brute-force this puzzle by simply calculating the fuel requirement at every single point (within the range of the inputs), you can do it about 200× faster by treating it as an optimization problem.</p>
<p>The total fuel required for any potential position is</p>
<pre class="r"><code>x &lt;- scan(&#39;input.txt&#39;, sep = &#39;,&#39;)
f &lt;- function(pos) sum(abs(x - pos))</code></pre>
<p>where <code>x</code> are the initial locations of the crabs.
Then run it through <code>optimize()</code>, and round to the nearest integer position:</p>
<pre class="r"><code>sol &lt;- optimize(f, range(x))$minimum
f(round(sol))</code></pre>
<p>However, there is an even faster analytical solution!</p>
<pre class="r"><code>sol &lt;- median(x)</code></pre>
<p>Thanks to <a href="https://twitter.com/claire_little1">Claire Little</a> for pointing this out.</p>
</div>
<div id="mean" class="section level3">
<h3>Mean</h3>
<p>Part two just has a slightly different function to optimize.
Using the formula for the sum of an <a href="https://en.wikipedia.org/wiki/Arithmetic_progression">arithmetic progression</a>:</p>
<pre class="r"><code>f2 &lt;- function(pos) {
  n &lt;- abs(x - pos)
  sum(n / 2 * (1 + n))
}</code></pre>
<p>Then we can simply minimize this function as before.</p>
<pre class="r"><code>sol &lt;- optimize(f2, range(x))$minimum
f2(round(sol))</code></pre>
<p>However, there’s a shortcut for this part as well!
Calculate the mean of the initial positions, and work out which of the two nearest integers gives the minimum result:</p>
<pre class="r"><code>min(
  f2(floor(mean(x))),
  f2(ceiling(mean(x)))
)</code></pre>
<p>Thanks to <a href="https://twitter.com/jonatanpallesen/status/1468165025575624704">Jonatan Pallesen</a>.
This is about 5 times faster than my optimizer.</p>
<p>And here is what the functions look like for my input dataset:</p>
<p><img src="/post/2021-12-01-advent_files/figure-html/day7-1.png" width="576" /></p>
</div>
</div>
<div id="day8" class="section level2">
<h2>Day 8 - <a href="https://adventofcode.com/2021/day/8">Seven Segment Search</a></h2>
<div id="unique-digits" class="section level3">
<h3>Unique digits</h3>
<p>Read in the data and then the first part is just a one-liner:</p>
<pre class="r"><code>input &lt;- do.call(rbind, strsplit(readLines(input_file(8)), &#39;[^a-z]+&#39;))

count_unique &lt;- function(x) {
  sum(nchar(x[, -(1:10)]) %in% c(2, 3, 4, 7))
}</code></pre>
</div>
<div id="segment-matching" class="section level3">
<h3>Segment matching</h3>
<p>I <em>really</em> wanted to solve part two using graph theory, by representing the puzzle as a maximum bipartite matching problem.
However, I couldn’t quite get this to work.
My final solution is instead just a lot of leg work.</p>
<p>Essentially you solve the problem by hand and then encode the process programmatically.
Recognize that some digits have segments in common, or not in common, and use this to eliminate the possibilities.
I stored the solutions in a named vector, which I was able to use to look up the digits found so far.</p>
<p>The function <code>setdiff()</code> comes in useful.</p>
<pre class="r"><code>contains &lt;- function(strings, letters) {
  vapply(strsplit(strings, &#39;&#39;),
         function(s) all(strsplit(letters, &#39;&#39;)[[1]] %in% s),
         logical(1))
}

output_value &lt;- function(vec) {
  segments &lt;- c(&#39;abcefg&#39;, &#39;cf&#39;, &#39;acdeg&#39;, &#39;acdfg&#39;, &#39;bcdf&#39;,
                &#39;abdfg&#39;, &#39;abdefg&#39;, &#39;acf&#39;, &#39;abcdefg&#39;, &#39;abcdfg&#39;)
  nchars &lt;- setNames(nchar(segments), 0:9)

  # Sort the strings
  vec &lt;- sapply(strsplit(vec, &#39;&#39;), function(d) paste(sort(d), collapse = &#39;&#39;))
  sgn &lt;- head(vec, 10)
  out &lt;- tail(vec, 4)

  # Store the known values
  digits &lt;- setNames(character(10), 0:9)
  unique &lt;- c(&#39;1&#39;, &#39;4&#39;, &#39;7&#39;, &#39;8&#39;)
  digits[unique] &lt;- sgn[match(nchars[unique], nchar(sgn))]

  # Remaining digits have 5 or 6 segments:
  sgn &lt;- setdiff(sgn, digits)
  digits[&#39;3&#39;] &lt;- sgn[nchar(sgn) == 5 &amp; contains(sgn, digits[&#39;1&#39;])]
  digits[&#39;6&#39;] &lt;- sgn[nchar(sgn) == 6 &amp; !contains(sgn, digits[&#39;1&#39;])]
  sgn &lt;- setdiff(sgn, digits)
  digits[&#39;0&#39;] &lt;- sgn[nchar(sgn) == 6 &amp; !contains(sgn, digits[&#39;4&#39;])]
  sgn &lt;- setdiff(sgn, digits)
  digits[&#39;9&#39;] &lt;- sgn[nchar(sgn) == 6]
  sgn &lt;- setdiff(sgn, digits)
  digits[&#39;2&#39;] &lt;- sgn[
    contains(sgn, do.call(setdiff,
                          unname(strsplit(digits[c(&#39;8&#39;, &#39;6&#39;)], &#39;&#39;))))
  ]
  digits[&#39;5&#39;] &lt;- setdiff(sgn, digits)

  # Combine four output digits:
  as.numeric(paste(match(out, digits) - 1, collapse = &#39;&#39;))
}</code></pre>
</div>
</div>
<div id="day9" class="section level2">
<h2>Day 9 - <a href="https://adventofcode.com/2021/day/9">Smoke Basin</a></h2>
<div id="lowest-points" class="section level3">
<h3>Lowest points</h3>
<p>You can find all the lowest points with a one-liner:</p>
<pre class="r"><code>lowest &lt;- function(h) {
  h &lt; cbind(h, Inf)[, -1] &amp;          # right
    h &lt; rbind(h, Inf)[-1, ] &amp;        # down
    h &lt; cbind(Inf, h[, -ncol(h)]) &amp;  # left
    h &lt; rbind(Inf, h[-nrow(h), ])    # up
}</code></pre>
<p>Then do <code>sum(h[lowest(h)])</code> to get the result, where <code>h</code> is a numeric matrix of the input data.</p>
</div>
<div id="basins" class="section level3">
<h3>Basins</h3>
<p>The second part is harder and doesn’t immediately lead from the first.
Initially I thought of replacing each lowest point with <code>Inf</code>, then finding the new lowest points and repeating the process until all the basins are found.
However, the basins are simply all points where the height is <code>&lt; 9</code>, so you can find the basins in a single step.</p>
<p>The tricky part is labelling them separately, so you can count up their respective sizes.</p>
<p>The boring way of doing this is just to loop over the indices and label the points that neighbour already-labelled ones (starting with the lowest points as the initial labels), doing several passes until everything (except the 9s) is labelled.</p>
<pre class="r"><code>basins &lt;- function(h) {
  l &lt;- lowest(h)
  h[] &lt;- ifelse(h &lt; 9, NA, Inf)
  h[l] &lt;- 1:sum(l)
  while (anyNA(h)) {
    for (i in 1:nrow(h)) for (j in 1:ncol(h)) {
      if (is.na(h[i, j])) {
        nbrs &lt;- h[cbind(c(max(i - 1, 1), min(i + 1, nrow(h)), i, i),
                        c(j, j, max(j - 1, 1), min(j + 1, ncol(h))))]
        if (any(is.finite(nbrs)))
          h[i, j] &lt;- nbrs[is.finite(nbrs)][1]
      }
    }
  }
  sizes &lt;- table(h[is.finite(h)])
  head(sort(sizes, decreasing = TRUE), 3)
}</code></pre>
<p>To vectorize this in the same way as part one, we define a new binary (infix) operator <code>%c%</code>, analogous to <code>dplyr::coalesce()</code>.
What this does is replace an <code>NA</code> value (a basin not yet assigned a label) with its finite neighbour, while leaving <code>Inf</code>s (marking basin edges) alone.</p>
<pre class="r"><code>&quot;%c%&quot; &lt;- function(x, y) {
  ifelse(is.infinite(x), x,
         ifelse(!is.na(x), x,
                ifelse(!is.infinite(y), y, x)))
}</code></pre>
<p>Then the new function for part two is as follows.
It is five times faster to run than the nested loop above.</p>
<pre class="r"><code>basins2 &lt;- function(h) {
  l &lt;- lowest(h)
  h[] &lt;- ifelse(h &lt; 9, NA, Inf)
  h[l] &lt;- 1:sum(l)
  while(anyNA(h)) {
    h &lt;- h %c%
      cbind(h, NA)[, -1] %c%        # right
      rbind(h, NA)[-1, ] %c%        # down
      cbind(NA, h[, -ncol(h)]) %c%  # left
      rbind(NA, h[-nrow(h), ])      # up
  }
  sizes &lt;- table(h[is.finite(h)])
  head(sort(sizes, decreasing = TRUE), 3)
}</code></pre>
<p>You can also <a href="https://twitter.com/rappa753/status/1468876602016735233">formulate this as an image analysis problem</a>, effectively treating each basin as an area of similar colour to select, or you can <a href="https://twitter.com/babeheim/status/1468898580408811525">treat it as a network theory problem and apply the <strong>igraph</strong> package</a> to find graph components.</p>
</div>
</div>
<div id="day10" class="section level2">
<h2>Day 10 - <a href="https://adventofcode.com/2021/day/10">Syntax Scoring</a></h2>
<div id="corrupt-characters" class="section level3">
<h3>Corrupt characters</h3>
<p>Whilst it’s probably possible to do the first part with some very fancy <a href="https://www.php.net/manual/en/regexp.reference.recursive.php">recursive regular expressions</a>, I don’t know how to use them.</p>
<p>Instead, my method of finding unmatched brackets is simply to search for empty pairs of brackets and successively strip them from the string.
Keep doing this until the strings stop changing.
Then, get the first closing bracket (if any), using <code>regmatches()</code>.
These are the illegal characters.</p>
<p>My function <a href="https://github.com/Selbosh/adventofcode2021/blob/main/R/day10.R#L122-L128"><code>syntax_score()</code></a> is implemented as follows:</p>
<pre class="r"><code>lines &lt;- readLines(&#39;input.txt&#39;)
old &lt;- &#39;&#39;
while (!identical(old, lines -&gt; old))
  lines &lt;- gsub(r&#39;(\(\)|&lt;&gt;|\{\}|\[\])&#39;, &#39;&#39;, lines)
illegals &lt;- regmatches(lines, regexpr(r&#39;(\)|&gt;|\}|\])&#39;, lines))</code></pre>
<p>The syntax score is calculated using a named vector as a lookup table.</p>
<pre class="r"><code>illegal_score &lt;- c(&#39;)&#39; = 3, &#39;]&#39; = 57, &#39;}&#39; = 1197, &#39;&gt;&#39; = 25137)
sum(illegal_score[illegals])</code></pre>
</div>
<div id="autocomplete" class="section level3">
<h3>Autocomplete</h3>
<p>Part two starts the same, but instead of extracting the illegal characters we just throw away those lines that contain them.</p>
<pre class="r"><code>illegals &lt;- grep(r&#39;(\)|&gt;|\}|\])&#39;, lines)
chars &lt;- strsplit(lines[-illegals], &#39;&#39;)</code></pre>
<p>From here, we can calculate the scores using a <code>Reduce</code> operation (from right to left) with another lookup table.
The final answer is the median score.</p>
<pre class="r"><code>complete_score &lt;- c(&#39;(&#39; = 1, &#39;[&#39; = 2, &#39;{&#39; = 3, &#39;&lt;&#39; = 4)
scores &lt;- sapply(chars, Reduce, init = 0, right = TRUE,
                 f = \(c, s) 5 * s + complete_score[c])
median(scores)</code></pre>
<p>The function <a href="https://github.com/Selbosh/adventofcode2021/blob/main/R/day10.R#L132-L141"><code>autocomplete()</code></a> wraps it all together.</p>
</div>
</div>
<div id="day11" class="section level2">
<h2>Day 11 - <a href="https://adventofcode.com/2021/day/11">Dumbo Octopus</a></h2>
<div id="convoluted-octopuses" class="section level3">
<h3>Convoluted octopuses</h3>
<p>This is the first problem this year in which I’ve resorted to using an external package; everything has been in base R so far.</p>
<p>The process of updating the energy levels can be described using a <a href="https://en.wikipedia.org/wiki/Kernel_(image_processing)"><em>convolution matrix</em></a>.
While I could probably write a function to do this, it’s easier—<a href="https://selbydavid.com/2020/12/06/advent-2020/#day11">like on Day 11 last year</a>—to use a ready-made solution from an image analysis package, namely <code>OpenImageR::convolution()</code>.</p>
<p>The convolution matrix, or <em>kernel</em> is
<span class="math display">\[\begin{bmatrix}1  &amp;  1  &amp;  1 \\1  &amp;   0  &amp;  1 \\1  &amp;  1  &amp;  1\end{bmatrix},\]</span>
to be applied on an indicator matrix of ‘flashing’ octopuses, and then added to the result.
In R,</p>
<pre class="r"><code>kernel &lt;- matrix(1:9 != 5, 3, 3)</code></pre>
<p>So we define a function, <code>step1()</code>, that applies a single step of the energy level updating process.
Since each octopus can only flash once in a given step, we keep track of those that have already flashed, as well as those currently flashing.
A short <code>while()</code> loop repeats until no more octopuses flash.</p>
<pre class="r"><code>step1 &lt;- function(x) {
  x &lt;- x + 1
  flashing &lt;- flashed &lt;- x == 10
  while (any(flashing)) {
    x &lt;- x + OpenImageR::convolution(flashing, kernel)
    flashing &lt;- x &gt; 9 &amp; !flashed
    flashed &lt;- flashing | flashed
  }
  x[x &gt; 9] &lt;- 0
  x
}</code></pre>
</div>
<div id="counting-flashes" class="section level3">
<h3>Counting flashes</h3>
<p>We then solve both parts one and two with a single function that repeatedly applies the updating step and counts the flashes (number of zeros) each time.</p>
<p>By default, it simply completes <code>iter</code> steps and then returns cumulative total number of flashes.</p>
<p>In <code>part2</code> mode, the function will terminate early if it encounters a step where all the octopuses are flashing and return the iteration number, otherwise it will generate a warning.</p>
<pre class="r"><code>count_flashes &lt;- function(x, iter = 100, part2 = FALSE) {
  count &lt;- 0
  for (i in 1:iter) {
    x &lt;- step1(x)
    nflashes &lt;- sum(x == 0)
    if (part2 &amp; nflashes == prod(dim(x)))
      return(i)
    count &lt;- count + nflashes
  }
  if (part2)
    warning(&#39;No synchronization detected in &#39;, iter, &#39; steps&#39;)
  count
}</code></pre>
<p>The whole thing runs in about 20 milliseconds on my input dataset.</p>
</div>
</div>
